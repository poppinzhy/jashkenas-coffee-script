// Generated by CoffeeScript 1.5.0
(function() {
  var CoffeeScript, CompilerError, addMultilineHandler, merge, nodeREPL, replDefaults, vm;

  vm = require('vm');

  nodeREPL = require('repl');

  CoffeeScript = require('./coffee-script');

  CompilerError = require('./error').CompilerError;

  merge = require('./helpers').merge;

  replDefaults = {
    prompt: 'coffee> ',
    "eval": function(input, context, filename, cb) {
      var Assign, Block, Literal, Value, ast, js, _ref;
      input = input.replace(/\uFF00/g, '\n');
      input = input.replace(/^\(([\s\S]*)\n\)$/m, '$1');
      _ref = require('./nodes'), Block = _ref.Block, Assign = _ref.Assign, Value = _ref.Value, Literal = _ref.Literal;
      try {
        ast = CoffeeScript.nodes(input);
        ast = new Block([new Assign(new Value(new Literal('_')), ast, '=')]);
        js = ast.compile({
          bare: true
        });
      } catch (err) {
        if (err instanceof CompilerError) {
          console.log(err.prettyMessage(filename, input, true));
        } else {
          cb(err);
        }
      }
      return cb(null, vm.runInContext(js, context, filename));
    }
  };

  addMultilineHandler = function(repl) {
    var inputStream, multiline, nodeLineListener, outputStream, rli;
    rli = repl.rli, inputStream = repl.inputStream, outputStream = repl.outputStream;
    multiline = {
      enabled: false,
      initialPrompt: repl.prompt.replace(/^[^> ]*/, function(x) {
        return x.replace(/./g, '-');
      }),
      prompt: repl.prompt.replace(/^[^> ]*>?/, function(x) {
        return x.replace(/./g, '.');
      }),
      buffer: ''
    };
    nodeLineListener = rli.listeners('line')[0];
    rli.removeListener('line', nodeLineListener);
    rli.on('line', function(cmd) {
      if (multiline.enabled) {
        multiline.buffer += "" + cmd + "\n";
        rli.setPrompt(multiline.prompt);
        rli.prompt(true);
      } else {
        nodeLineListener(cmd);
      }
    });
    return inputStream.on('keypress', function(char, key) {
      if (!(key && key.ctrl && !key.meta && !key.shift && key.name === 'v')) {
        return;
      }
      if (multiline.enabled) {
        if (!multiline.buffer.match(/\n/)) {
          multiline.enabled = !multiline.enabled;
          rli.setPrompt(repl.prompt);
          rli.prompt(true);
          return;
        }
        if ((rli.line != null) && !rli.line.match(/^\s*$/)) {
          return;
        }
        multiline.enabled = !multiline.enabled;
        rli.line = '';
        rli.cursor = 0;
        rli.output.cursorTo(0);
        rli.output.clearLine(1);
        multiline.buffer = multiline.buffer.replace(/\n/g, '\uFF00');
        rli.emit('line', multiline.buffer);
        multiline.buffer = '';
      } else {
        multiline.enabled = !multiline.enabled;
        rli.setPrompt(multiline.initialPrompt);
        rli.prompt(true);
      }
    });
  };

  module.exports = {
    start: function(opts) {
      var repl;
      if (opts == null) {
        opts = {};
      }
      opts = merge(replDefaults, opts);
      repl = nodeREPL.start(opts);
      repl.on('exit', function() {
        return repl.outputStream.write('\n');
      });
      addMultilineHandler(repl);
      return repl;
    }
  };

}).call(this);
